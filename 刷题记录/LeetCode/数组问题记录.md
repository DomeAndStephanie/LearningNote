[TOC]

#### 数组问题解题记录



##### 189.旋转数组

```
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/rotate-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

方法：

- 使用一个数组依次计算移动后的位置进行赋值，空间换时间

- 若要将数组中的元素向右移动`k`个位置，那么`k % len`的尾部元素会被移动到头部，剩下的元素向后移动。基于此可通过三次反转，第一次反转整个数组，则需要向右移动的元素都到了前面；接着反转前`k`和元素和后面`len - k`个元素，则可得结果。

  ```java
  /**
       * 旋转数组
       * @param nums 原数组
       * @param k 旋转点
       */
  public void rotate(int[] nums, int k) {
      rotateHelper(nums, 0, nums.length);
      rotateHelper(nums, 0, k% nums.length - 1);
      rotateHelper(nums, k % nums.length, nums.length - 1);
  }
  /**
       * 对称交换数组元素
       * @param array 原数组
       * @param start 起始位置
       * @param end 结束位置
       */
  private void rotateHelper(int[] array, int start, int end) {
      while (start < end) {
          array[start] = array[start] ^ array[end];
          array[end] = array[start] ^ array[end];
          array[start] = array[start] ^ array[end];
          start++;
          end --;
      }
  }
  ```

##### 461.汉明距离 

```
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 2^31.

示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/hamming-distance
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

方法：先计算两个数的异或，然后统计异或后的数中1的个数.

```java
/**
     * 汉明距离
     * @param x 参数x
     * @param y 参数y
     * @return x与y之间的汉明距离
     */
public static int hammingDistance(int x, int y) {
    //计算异或
    int xor = x ^ y;
    int distance = 0;
    while (xor != 0 ){
        //统计最右的数是否为1
        if ((xor & 1) == 1) {
            distance++;
        }
        //向右移一位
        xor = xor >> 1;
    }
    return distance;
}
```




##### 1109.航班预订统计

```
这里有 n 个航班，它们分别从 1 到 n 进行编号。

我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。

请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。

 

示例：

输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
 

提示：

1 <= bookings.length <= 20000
1 <= bookings[i][0] <= bookings[i][1] <= n <= 20000
1 <= bookings[i][2] <= 10000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/corporate-flight-bookings
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

方法：使用[差分数组](../tips/前缀和与差分数组.md)对所给区间进行加减即可

```java
/**
     * 航班预订统计
     * @param bookings 航班信息
     * @param n 航班数
     * @return 航班座位数组
     */
public int[] corpFlightBookings(int[][] bookings, int n) {
    int[] result = new int[n];
    Difference diff = new Difference(result);
    for (int i = 0; i < bookings.length; i ++) {
        int[] nums = bookings[i];
        diff.increment(nums[0] - 1, nums[1] - 1, nums[2]);
    }
    return diff.result();
}
```

